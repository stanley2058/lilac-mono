# Attachments + Workflows (Bus <> Agent) Plan (v1)

This plan covers two cross-cutting capabilities needed for production agent flows:
- tool-driven attachments (files generated by tools -> surfaced in Discord)
- workflows (async/long-running tasks -> resume agent later)

It is designed to compose with:
- `BUS_REQUEST_ROUTER_PLAN.md`
- `BUS_AGENT_RUNNER_PLAN.md`
- `BUS_ADAPTER_BRIDGE_PLAN.md` (bus -> adapter output relay)

## Part A: Attachments

### Problem

We support attachments in the Discord adapter output stream, but there is no standard way for tools to attach files to:
- the current request stream, or
- another session

We also want tools to be session-agnostic:
- tool code should not care which adapter/session it runs under
- default is "current session" derived from env
- optional override accepts a future-proof `session` identifier

### Design

#### A1) Introduce a tool: attachment.add_files

- Implement in `apps/tool-bridge` as a new tool callable id: `attachment.add_files`.
- Input (draft):
  - `paths: string[]` (file paths on local filesystem)
  - `filenames?: string[]`
  - `mimeTypes?: string[]`
  - `session?: string` (optional override; in v1 can be treated as `session_id`)
  - `request?: string` (optional override; in v1 can be treated as `request_id`)

Defaults (if not passed):
- `request_id` from env `LILAC_REQUEST_ID` (if present)
- `session_id` from env `LILAC_SESSION_ID` (if present)
- `request_client` from env `LILAC_REQUEST_CLIENT` (if present)

Output:
- `{ ok: true, bytes: number, filename, mimeType }` (for model visibility)

#### A2) New bus command: cmd.attachment.add

Because this is a system action, model tool calls should publish a *command*.

- `type`: `cmd.attachment.add` (new event type)
- `topic`: `cmd.attachment`
- headers (optional but recommended):
  - `request_id?: string`
  - `session_id?: string`
  - `request_client?: string`
- data:
  - either inline bytes:
    - `{ mimeType, dataBase64, filename? }`
  - or a reference:
    - `{ path, filename?, mimeType? }`

Recommendation for v1: publish inline bytes (base64) to avoid shared-filesystem assumptions across processes.

#### A3) Attachment routing is owned by agent-runner

Agent-runner is the authoritative registry for active requests per session.

Agent-runner consumes `cmd.attachment.add` and decides:

1) If `request_id` is provided or can be inferred:
   - publish `evt.agent.output.response.binary` with `headers.request_id` set
   - this automatically enters the existing out stream (`out.req.${request_id}`) and is delivered by `apps/core/src/surface/bridge/subscribe-from-bus.ts`

2) Else if only `session_id` is provided:
   - look up the active request for that session
   - if found: publish `evt.agent.output.response.binary` to that request
   - if not found: reject (or optionally create a new "system" request; out of scope for v1)

Delivery semantics:
- If the attachment arrives before the first Discord send, it can be included in the first message.
- If it arrives mid-stream, Discord output stream already supports sending attachments as follow-up messages when streaming finishes.

### Acceptance Criteria (attachments)

- Tool can call `attachment.add_files({ paths: [path] })` during a request and the user sees the file in Discord.
- Tool can call `attachment.add_files({ paths: [path], session })` and it attaches to the active request in that session (if any).
- Tool does not need to know request/session ids explicitly when invoked inside a request (env default works).

## Part B: Workflows

### Problem

Some tasks are inherently asynchronous:
- send a DM and wait for a reply
- wait for an external event
- long-running background jobs

We need a way to:
- suspend a request
- create one or more tasks
- resume later with context

### Design

#### B1) Workflow service

Implement a dedicated workflow service that consumes `cmd.workflow.*` and emits `evt.workflow.*`.

Minimal persistence:
- store workflow definitions + task state in Redis (hashes) or SQLite.

Minimal task types for v1:
- `discord.dm.send`
  - input: `{ userId, text, attachments? }`
  - output: `{ channelId, messageId }`
- `discord.wait_for_reply`
  - input: `{ channelId, messageId }`
  - resolves when an `evt.adapter.message.created` indicates a reply to that message

The workflow service must subscribe to `evt.adapter.message.created` to detect replies.

#### B2) Agent tools for workflow

Add workflow tools in the agent-runner toolset:
- `workflow.create`
- `workflow.task.create`
- `workflow.wait_for_reply`

A simple recommended pattern:
1) Agent calls `workflow.create` (agent-runner publishes `cmd.workflow.create`)
2) Agent calls `workflow.task.create` for each async action
3) Agent finalizes the current run with an acknowledgement message

#### B3) Resume semantics

When a workflow resolves:
- workflow service publishes a new `cmd.request.message` to the agent-runner.

Resume request headers:
- `request_id`: original request id (so output threads to the original Discord message)
- `session_id`: original session id
- `request_client`: original client

Resume request payload:
- `queue: "prompt"`
- `messages`: should include either:
  - the new triggering message content (e.g. the DM reply), and/or
  - a compacted summary of prior context (agent-runner can store a summary when creating the workflow)

This causes the adapter bridge to reply back into the original thread.

### Acceptance Criteria (workflows)

- Agent can create a workflow that waits on a DM reply.
- When the DM reply occurs, the workflow service resumes the agent and the agent replies to the original request thread.
- Resume does not require router involvement (router can ignore workflow-driven requests).
